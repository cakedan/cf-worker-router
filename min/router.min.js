(()=>{"use strict";var e={d:(t,r)=>{for(var s in r)e.o(r,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:r[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{HttpMethods:()=>n,HttpStatusCodes:()=>a,Package:()=>i,RouteRegexps:()=>u});var r={};e.r(r),e.d(r,{Route:()=>d,RouteMap:()=>p,Router:()=>R,RouterEvent:()=>f,checkHttpMethods:()=>h,extractParameters:()=>l,urlToRegexp:()=>c});var s={};e.r(s),e.d(s,{ApiError:()=>y,ApiRedirect:()=>g,ApiResponse:()=>E});var o={};e.r(o),e.d(o,{BlueprintRouter:()=>m,DomainRouter:()=>A,FetchRouter:()=>T});const i=Object.freeze({URL:"https://github.com/cakedan/cf-worker-router",VERSION:"0.2.0"}),n=Object.freeze({DELETE:"DELETE",GET:"GET",HEAD:"HEAD",OPTIONS:"OPTIONS",PATCH:"PATCH",POST:"POST",PUT:"PUT"}),a=Object.freeze({100:"Continue",101:"Switching Protocols",102:"Processing",200:"OK",201:"Created",202:"Accepted",203:"Non Authoritative Information",204:"No Content",205:"Reset Content",206:"Partial Content",207:"Multi Status",226:"IM Used",300:"Multiple Choices",301:"Moved Permanently",302:"Found",303:"See Other",304:"Not Modified",305:"Use Proxy",307:"Temporary Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",406:"Not Acceptable",407:"Proxy Authentication Required",408:"Request Timeout",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Request Entity Too Large",414:"Request URI Too Long",415:"Unsupported Media Type",416:"Requested Range Not Satisfiable",417:"Expectation Failed",418:"I'm a teapot",421:"Misdirected Request",422:"Unprocessable Entity",423:"Locked",424:"Failed Dependency",426:"Upgrade Required",428:"Precondition Required",429:"Too Many Requests",431:"Request Header Fields Too Large",449:"Retry With",451:"Unavailable For Legal Reasons",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway Timeout",505:"HTTP Version Not Supported",507:"Insufficient Storage",510:"Not Extended"}),u=Object.freeze({PARAMETER:/(?:[:*])(\w+)/g,PARAMETER_REPLACEMENT:"([^/]+)",PARAMETER_WILDCARD_DOTS:/(?:\(\.\*\))(\.{3})/g,PARAMETER_WILDCARD_REPLACEMENT:"(.*)",SLASH_OPTIONAL:"(?:/$|$)",WILDCARD:/\*/g,WILDCARD_REPLACEMENT:"(?:.*)"});function h(e){if("string"==typeof e)e="*"===e?Object.values(n):[e];else if(!Array.isArray(e))throw new TypeError("Methods must be a string or a list of strings");if(e=e.map(e=>e.toUpperCase()),!(e=Array.from(new Set(e)).filter(e=>e in n)).length)throw new TypeError("Methods must contain at least one valid http method");return e.sort()}function l(e,t,r={}){return e&&e.length-1===t.length?e.slice(1).reduce((e,r,s)=>(e[t[s]]=decodeURIComponent(r),e),r):null}function c(e){e.startsWith("/")&&(e="^*"+e),e.startsWith("^")||(e="^"+e);const t=[];return{regexp:new RegExp(e.replace(u.WILDCARD,u.WILDCARD_REPLACEMENT).replace(u.PARAMETER,(r,s,o)=>{t.push(s);const i=r.length+o;return"..."===e.slice(i,i+3)?u.PARAMETER_WILDCARD_REPLACEMENT:u.PARAMETER_REPLACEMENT}).replace(u.PARAMETER_WILDCARD_DOTS,u.PARAMETER_WILDCARD_REPLACEMENT)+u.SLASH_OPTIONAL),variables:t}}class d{handler;key;methods;regexp;variables;pass=!1;priority=0;constructor(e,t,r,s={}){if("function"==typeof t?(s=r,r=t,t=[n.GET]):"object"!=typeof t||Array.isArray(t)?("object"==typeof r&&(s=r),t=h(t)):(s=t,t=[n.GET]),s=Object.assign({pass:this.pass,priority:this.priority},s),"function"!=typeof r&&!s.pass)throw new TypeError("Handler has to be of function type or options must have pass as true");this.handler=r,this.methods=t,this.pass=s.pass||this.pass,this.priority=s.priority||this.priority;const{regexp:o,variables:i}=c(e);this.key=this.methods.join(".")+"#"+o,this.regexp=o,this.variables=i}matches(e){return!!e.match(this.regexp)}async handle(e){if(l(e.route.match(this.regexp),this.variables,e.parameters),this.handler)return this.handler(e)}}class p extends Map{routers=new Map;add(e){if(e instanceof d){if(this.has(e.key))throw new TypeError(`Route ${e.key} already exists`);this.set(e.key,e)}else{if(!(e instanceof R))throw new TypeError("Route must be of type Route or Router");{const t=e;if(!t.key)throw new TypeError("Router must have a key");if(this.routers.has(t.key))throw new TypeError(`Router with key ${t.key} already exists`);this.routers.set(t.key,t)}}}findAll(e){const t=[];for(let r of this.values())r.matches(e)&&t.push(r);for(let r of this.routers.values()){const s=r.routes.findAll(e);s.length&&t.push(s)}return t.flat().sort((e,t)=>t.key.length-e.key.length).sort((e,t)=>t.priority-e.priority)}}class R{routes=new p;key=null;route(e,t,r,s={}){if(Array.isArray(e))for(let o of e)this.routes.add(new d(o,t,r,s));else this.routes.add(new d(e,t,r,s));return this}delete(e,t,r={}){return this.route(e,[n.DELETE],t,r)}get(e,t,r={}){return this.route(e,[n.GET],t,r)}head(e,t,r={}){return this.route(e,[n.HEAD],t,r)}options(e,t,r={}){return this.route(e,[n.OPTIONS],t,r)}post(e,t,r={}){return this.route(e,[n.POST],t,r)}put(e,t,r={}){return this.route(e,[n.PUT],t,r)}}class f{fetchEvent=null;route;url;_originalRequest=null;_request=null;context=null;environment={};parameters={};constructor(e,t,r){e instanceof Request?this._originalRequest=e:e instanceof FetchEvent&&(this.fetchEvent=e),t&&(this.environment=t),r&&(this.context=r),this.url=new URL(this.originalRequest.url),this.route=this.url.hostname+this.url.pathname.replace(/^\/+/,"/")}get headers(){return this.originalRequest.headers}get ip(){return this.headers.get("cf-connecting-ip")||this.headers.get("x-real-ip")||""}get ipv4(){return this.headers.get("x-real-ip")||""}get method(){return this.originalRequest.method}get originalRequest(){if(this.fetchEvent)return this.fetchEvent.request;if(this._originalRequest)return this._originalRequest;throw new Error("Invalid FetchEvent or Request was passed in.")}get query(){return this.url.searchParams}get request(){return this._request?this._request:this._request=new Request(this.originalRequest)}respondWith(e){return this.fetchEvent?this.fetchEvent.respondWith(e):Promise.resolve(e)}pass(){return fetch(this._request?this._request:this.originalRequest)}}class E extends Response{constructor(e,t={}){(t=Object.assign({},t)).headers=Object.assign({"content-type":"application/json"},t.headers),t.status||(t.status=200),void 0===t.statusText&&t.status in a&&(t.statusText=a[t.status]),"application/json"===t.headers["content-type"]&&(e=JSON.stringify(e)),super(e,t)}}class y extends E{constructor(e={}){const t=(e=Object.assign({status:400,code:0},e)).status;if(t<400||600<=t)throw new Error("Invalid Status Code, Errors should be equal to or between 400 and 599.");void 0===e.statusText&&t in a&&(e.statusText=a[t]),void 0===e.message&&(e.message=e.statusText),super(Object.assign({},e.metadata,{code:e.code,message:e.message,status:e.status}),e)}}class g extends E{constructor(e,t={}){const r=(t=Object.assign({status:302},t)).status;if(r<300||400<=r)throw new Error("Invalid Status Code, Redirects should be equal to or between 300 and 399.");t.headers=Object.assign({},t.headers,{location:e}),super(void 0,t)}}class T extends R{showServerError=!0;beforeResponse;constructor(e={}){super(),e=Object.assign({showServerError:this.showServerError},e),this.showServerError=!!e.showServerError}addRouter(e){this.routes.add(e)}_beforeResponse(e,t){if("function"==typeof this.beforeResponse){const r=this.beforeResponse(e,t);r&&(e=r instanceof Response?r:new E(r))}return e}onFetch(e,t,r){const s=new f(e,t,r);let o=this.routes.findAll(s.route);if(!o.length){const e=this._beforeResponse(new y({status:404}),s);return s.respondWith(e)}if(o=o.filter(e=>e.methods.includes(s.method)),!o.length){const e=this._beforeResponse(new y({status:405}),s);return s.respondWith(e)}const i=o.shift();if(!i.pass)return s.respondWith(this.onRoute(s,i))}async onRoute(e,t){let r;try{r=await t.handle(e),r instanceof Response||(r=new E(r))}catch(e){const t={status:500};this.showServerError&&(t.metadata={error:String(e)}),r=new y(t)}return this._beforeResponse(r,e)}}class A extends R{domain;constructor(e="*",t){super(),this.domain=e,this.key=t||e}route(e,t,r,s={}){if(Array.isArray(e))for(let o of e){if(!o.startsWith("/"))throw new TypeError("DomainRouter routes need to be paths!");super.route.call(this,this.domain+o,t,r,s)}else super.route.call(this,this.domain+e,t,r,s);return this}addBlueprint(e){if(!(e instanceof m))throw new TypeError("Blueprint must be of type BlueprintRouter");return this.routes.add(e),this}}class m extends R{path;constructor(e="",t){super(),this.path=e,this.key=t||e}route(e,t,r,s={}){if(Array.isArray(e))for(let o of e)super.route.call(this,this.path+o,t,r,s);else super.route.call(this,this.path+e,t,r,s);return this}}Object.assign(self||{},{CFWorkerRouter:{...t,...s,...o,Helpers:r}})})();