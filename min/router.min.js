!function(e){var t={};function r(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,s){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(r.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(s,o,function(t){return e[t]}.bind(null,o));return s},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=4)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Package=Object.freeze({URL:"https://github.com/cakedan/cf-worker-router",VERSION:"0.1.1"}),t.HttpMethods=Object.freeze({DELETE:"DELETE",GET:"GET",HEAD:"HEAD",OPTIONS:"OPTIONS",PATCH:"PATCH",POST:"POST",PUT:"PUT"}),t.HttpStatusCodes=Object.freeze({100:"Continue",101:"Switching Protocols",102:"Processing",200:"OK",201:"Created",202:"Accepted",203:"Non Authoritative Information",204:"No Content",205:"Reset Content",206:"Partial Content",207:"Multi Status",226:"IM Used",300:"Multiple Choices",301:"Moved Permanently",302:"Found",303:"See Other",304:"Not Modified",305:"Use Proxy",307:"Temporary Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",406:"Not Acceptable",407:"Proxy Authentication Required",408:"Request Timeout",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Request Entity Too Large",414:"Request URI Too Long",415:"Unsupported Media Type",416:"Requested Range Not Satisfiable",417:"Expectation Failed",418:"I'm a teapot",421:"Misdirected Request",422:"Unprocessable Entity",423:"Locked",424:"Failed Dependency",426:"Upgrade Required",428:"Precondition Required",429:"Too Many Requests",431:"Request Header Fields Too Large",449:"Retry With",451:"Unavailable For Legal Reasons",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway Timeout",505:"HTTP Version Not Supported",507:"Insufficient Storage",510:"Not Extended"}),t.RouteRegexps=Object.freeze({PARAMETER:/(?:[:*])(\w+)/g,PARAMETER_REPLACEMENT:"([^/]+)",PARAMETER_WILDCARD_DOTS:/(?:\(\.\*\))(\.{3})/g,PARAMETER_WILDCARD_REPLACEMENT:"(.*)",SLASH_OPTIONAL:"(?:/$|$)",WILDCARD:/\*/g,WILDCARD_REPLACEMENT:"(?:.*)"})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=r(0);class o extends Response{constructor(e,t={}){switch((t=Object.assign({},t)).headers=Object.assign({"content-type":"application/json"},t.headers),t.status||(t.status=200),void 0===t.statusText&&t.status in s.HttpStatusCodes&&(t.statusText=s.HttpStatusCodes[t.status]),t.headers["content-type"]){case"application/json":e=JSON.stringify(e)}super(e,t)}}t.ApiResponse=o;t.ApiError=class extends o{constructor(e={}){const t=(e=Object.assign({status:400,code:0},e)).status;if(t<400||600<=t)throw new Error("Invalid Status Code, Errors should be equal to or between 400 and 599.");void 0===e.statusText&&t in s.HttpStatusCodes&&(e.statusText=s.HttpStatusCodes[t]),void 0===e.message&&(e.message=e.statusText),super(Object.assign({},e.metadata,{code:e.code,message:e.message,status:e.status}),e)}};t.ApiRedirect=class extends o{constructor(e,t={}){const r=(t=Object.assign({status:302},t)).status;if(r<300||400<=r)throw new Error("Invalid Status Code, Redirects should be equal to or between 300 and 399.");t.headers=Object.assign({},t.headers,{location:e}),super(void 0,t)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=r(0);function o(e){if("string"==typeof e)e="*"===e?Object.values(s.HttpMethods):[e];else if(!Array.isArray(e))throw new TypeError("Methods must be a string or a list of strings");if(e=e.map(e=>e.toUpperCase()),!(e=Array.from(new Set(e)).filter(e=>e in s.HttpMethods)).length)throw new TypeError("Methods must contain at least one valid http method");return e.sort()}function n(e,t,r={}){return e&&e.length-1===t.length?e.slice(1).reduce((e,r,s)=>(e[t[s]]=decodeURIComponent(r),e),r):null}function i(e){e.startsWith("/")&&(e="^*"+e),e.startsWith("^")||(e="^"+e);const t=[];return{regexp:new RegExp(e.replace(s.RouteRegexps.WILDCARD,s.RouteRegexps.WILDCARD_REPLACEMENT).replace(s.RouteRegexps.PARAMETER,(r,o,n)=>{t.push(o);const i=r.length+n;return"..."===e.slice(i,i+3)?s.RouteRegexps.PARAMETER_WILDCARD_REPLACEMENT:s.RouteRegexps.PARAMETER_REPLACEMENT}).replace(s.RouteRegexps.PARAMETER_WILDCARD_DOTS,s.RouteRegexps.PARAMETER_WILDCARD_REPLACEMENT)+s.RouteRegexps.SLASH_OPTIONAL),variables:t}}t.checkHttpMethods=o,t.extractParameters=n,t.urlToRegexp=i;class u{constructor(e,t,r,n={}){if(this.pass=!1,this.priority=0,"function"==typeof t?(n=r,r=t,t=[s.HttpMethods.GET]):"object"!=typeof t||Array.isArray(t)?("object"==typeof r&&(n=r),t=o(t)):(n=t,t=[s.HttpMethods.GET]),r=r,t=t,n=Object.assign({pass:this.pass,priority:this.priority},n),"function"!=typeof r&&!n.pass)throw new TypeError("Handler has to be of function type or options must have pass as true");this.handler=r,this.methods=t,this.pass=n.pass||this.pass,this.priority=n.priority||this.priority;const{regexp:u,variables:a}=i(e);this.key=this.methods.join(".")+"#"+u,this.regexp=u,this.variables=a}matches(e){return!!e.match(this.regexp)}async handle(e){if(n(e.route.match(this.regexp),this.variables,e.parameters),this.handler)return this.handler(e)}}t.Route=u;class a extends Map{constructor(){super(...arguments),this.routers=new Map}add(e){if(e instanceof u){if(this.has(e.key))throw new TypeError(`Route ${e.key} already exists`);this.set(e.key,e)}else{if(!(e instanceof h))throw new TypeError("Route must be of type Route or Router");{const t=e;if(!t.key)throw new TypeError("Router must have a key");if(this.routers.has(t.key))throw new TypeError(`Router with key ${t.key} already exists`);this.routers.set(t.key,t)}}}findAll(e){const t=[];for(let r of this.values())r.matches(e)&&t.push(r);for(let r of this.routers.values()){const s=r.routes.findAll(e);s.length&&t.push(s)}return t.flat().sort((e,t)=>t.key.length-e.key.length).sort((e,t)=>t.priority-e.priority)}}t.RouteMap=a;class h{constructor(){this.routes=new a,this.key=null}route(e,t,r,s={}){if(Array.isArray(e))for(let o of e)this.routes.add(new u(o,t,r,s));else this.routes.add(new u(e,t,r,s));return this}delete(e,t,r={}){return this.route(e,[s.HttpMethods.DELETE],t,r)}get(e,t,r={}){return this.route(e,[s.HttpMethods.GET],t,r)}head(e,t,r={}){return this.route(e,[s.HttpMethods.HEAD],t,r)}options(e,t,r={}){return this.route(e,[s.HttpMethods.OPTIONS],t,r)}post(e,t,r={}){return this.route(e,[s.HttpMethods.POST],t,r)}put(e,t,r={}){return this.route(e,[s.HttpMethods.PUT],t,r)}}t.Router=h;t.RouterEvent=class{constructor(e){this._request=null,this.parameters={},this.fetchEvent=e,this.url=new URL(e.request.url),this.route=this.url.hostname+this.url.pathname.replace(/^\/+/,"/")}get headers(){return this.fetchEvent.request.headers}get ip(){return this.headers.get("cf-connecting-ip")||this.headers.get("x-real-ip")||""}get ipv4(){return this.headers.get("x-real-ip")||""}get method(){return this.fetchEvent.request.method}get originalRequest(){return this.fetchEvent.request}get query(){return this.url.searchParams}get request(){return this._request?this._request:this._request=new Request(this.originalRequest)}pass(){return fetch(this._request?this._request:this.originalRequest)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const s=r(1),o=r(2);t.FetchRouter=class extends o.Router{constructor(e={}){super(),this.showServerError=!0,e=Object.assign({showServerError:this.showServerError},e),this.showServerError=!!e.showServerError}addRouter(e){this.routes.add(e)}_beforeResponse(e,t){if("function"==typeof this.beforeResponse){const r=this.beforeResponse(e,t);r&&(e=r instanceof Response?r:new s.ApiResponse(r))}return e}onFetch(e){const t=new o.RouterEvent(e);let r=this.routes.findAll(t.route);if(!r.length){const r=this._beforeResponse(new s.ApiError({status:404}),t);return e.respondWith(r)}if(!(r=r.filter(e=>e.methods.includes(t.method))).length){const r=this._beforeResponse(new s.ApiError({status:405}),t);return e.respondWith(r)}const n=r.shift();if(!n.pass)return e.respondWith(this.onRoute(t,n))}async onRoute(e,t){let r;try{(r=await t.handle(e))instanceof Response||(r=new s.ApiResponse(r))}catch(e){const t={status:500};this.showServerError&&(t.metadata={error:String(e)}),r=new s.ApiError(t)}return this._beforeResponse(r,e)}};t.DomainRouter=class extends o.Router{constructor(e="*",t){super(),this.domain=e,this.key=t||e}route(e,t,r,s={}){if(Array.isArray(e))for(let o of e){if(!o.startsWith("/"))throw new TypeError("DomainRouter routes need to be paths!");super.route.call(this,this.domain+o,t,r,s)}else super.route.call(this,this.domain+e,t,r,s);return this}addBlueprint(e){if(!(e instanceof n))throw new TypeError("Blueprint must be of type BlueprintRouter");return this.routes.add(e),this}};class n extends o.Router{constructor(e="",t){super(),this.path=e,this.key=t||e}route(e,t,r,s={}){if(Array.isArray(e))for(let o of e)super.route.call(this,this.path+o,t,r,s);else super.route.call(this,this.path+e,t,r,s);return this}}t.BlueprintRouter=n},function(e,t,r){e.exports=r(5)},function(e,t,r){"use strict";function s(e){for(var r in e)t.hasOwnProperty(r)||(t[r]=e[r])}Object.defineProperty(t,"__esModule",{value:!0});const o=r(0),n=r(2);t.Helpers=n;const i=r(1),u=r(3);s(r(0)),s(r(1)),s(r(3)),Object.assign(self||{},{CFWorkerRouter:{...o,...i,...u,Helpers:n}})}]);